#! /bin/bash

################################################################################
# Author:
#   Ash Davies <@DrizzlyOwl>
# Version:
#   1.0.0
# Description:
#   Search an Azure Subscription for Azure Key Vaults that have Secrets with
#   expiry dates. If an expiry date is due within the next 90 days report it
# Usage:
#   ./kv-secret-scan.sh [-s <subscription name>] [-q]
#      -s       <subscription name>      (optional) Azure Subscription
#      -q                                (optional) Suppress output
#
#   If you do not specify the subscription name, the script will prompt you to
#   select one based on the current logged in Azure user
################################################################################

set -e

LOOKBACK_DAYS=90

# Calculate DATE_90 to be LOOKBACK_DAYS ago, prioritising gdate for consistency.
if command -v gdate >/dev/null 2>&1;
then
  DATE_90=$(gdate --date="$LOOKBACK_DAYS days ago" +"%Y-%m-%d")
else
  OS_TYPE=$(uname -s)
  if [ "$OS_TYPE" == "Darwin" ];
  then
    # macOS (BSD date) behavior for converting timestamp back to date
    current_timestamp=$(date "+%s")
    seconds_in_x_days=$((LOOKBACK_DAYS * 24 * 60 * 60))
    lookback_timestamp=$((current_timestamp - seconds_in_x_days))
    DATE_90=$(date -r "$lookback_timestamp" +"%Y-%m-%d")
  elif [ "$OS_TYPE" == "Linux" ];
  then
    # Linux (GNU date) behavior for converting timestamp back to date
    DATE_90=$(date --date="$LOOKBACK_DAYS days ago" +"%Y-%m-%d")
  fi
fi

SILENT=0

while getopts "s:q" opt; do
  case $opt in
    s)
      AZ_SUBSCRIPTION_SCOPE=$OPTARG
      ;;
    q)
      SILENT=1
      ;;
    *)
      ;;
  esac
done

# Entered a dead-end without user input
if [ "$SILENT" == 1 ] && [ -z "$AZ_SUBSCRIPTION_SCOPE" ]; then
  print "ERROR" "You must specify the Subscription ID or Name when using the silent switch"

  if [ "$NOTIFY" == 1 ]; then
    bash "$APP_ROOT/bin/notify" \
      -t "Error: Silent switch is used but no Subscription scope was specified. Unable to continue"
  fi

  exit 1
fi

# If a subscription scope has not been defined on the command line using '-e'
# then prompt the user to select a subscription from the account
if [ -z "${AZ_SUBSCRIPTION_SCOPE}" ]; then
  AZ_SUBSCRIPTIONS=$(
    az account list --output json |
    jq -c '[.[] | select(.state == "Enabled").name]'
  )

  print "INFO" "Choose an option: "
  AZ_SUBSCRIPTIONS="$(echo "$AZ_SUBSCRIPTIONS" | jq -r '. | join(",")')"

  # Read from the list of available subscriptions and prompt them to the user
  # with a numeric index for each one
  if [ -n "$AZ_SUBSCRIPTIONS" ]; then
    IFS=',' read -r -a array <<< "$AZ_SUBSCRIPTIONS"

    echo
    cat -n < <(printf "%s\n" "${array[@]}")
    echo

    n=""

    # Ask the user to select one of the indexes
    while true; do
        read -rp 'Select subscription to query: ' n
        # If $n is an integer between one and $count...
        if [ "$n" -eq "$n" ] && [ "$n" -gt 0 ]; then
          break
        fi
    done

    i=$((n-1)) # Arrays are zero-indexed
    AZ_SUBSCRIPTION_SCOPE="${array[$i]}"
  fi
fi

if [ "$NOTIFY" == 1 ]; then
  bash "$APP_ROOT/bin/notify" \
    -t "ðŸŽ¯ *Key Vault Secret Expiry Scan task started in \`$AZ_SUBSCRIPTION_SCOPE\`*"
fi

print "INFO" "Subscription: $AZ_SUBSCRIPTION_SCOPE"

# Find all Azure Key Vaults within the specified subscription
KV_LIST=$(
  az keyvault list \
    --only-show-errors \
    --subscription "$AZ_SUBSCRIPTION_SCOPE" |
  jq -rc '.[] | { "name": .name, "resourceGroup": .resourceGroup }'
)

if [ $? -ne 0 ]; then
  MSG="Failed to list Key Vaults in subscription '$AZ_SUBSCRIPTION_SCOPE'. Please check your Azure credentials and subscription."
  print "ERROR" "$MSG"

  if [ "$NOTIFY" == 1 ]; then
    bash "$APP_ROOT/bin/notify" \
      -t "Error: $MSG"
  fi
  exit 1
fi

COUNT_KEY_VAULT=0
TOTAL_SECRET_COUNT=0
TOTAL_EXPIRING_COUNT=0
TOTAL_EXPIRED_COUNT=0

for KEY_VAULT in $KV_LIST; do
  COUNT_KEY_VAULT=$((COUNT_KEY_VAULT+1))
  BIN_EXPIRED=""
  BIN_EXPIRING=""
  BIN_VALID=""
  KV_NAME=$(echo "$KEY_VAULT" | jq -rc '.name')

  print "INFO" "Azure Key Vault: $KV_NAME"

  SECRETS=$(
    az keyvault secret list \
      --vault-name "$KV_NAME" \
      --output json \
      --only-show-errors \
      --subscription "$AZ_SUBSCRIPTION_SCOPE" |
    jq '.[] | select(.attributes.enabled == true) | select(.attributes.expires != null) | { "secret_name": .name, "expiry_date": .attributes.expires }'
  )

  if [ $? -ne 0 ]; then
    print "WARNING" "Failed to list secrets for Key Vault '$KV_NAME'. Continuing with the next Key Vault."
    continue
  fi

  if [ -z "$SECRETS" ]; then
    print "INFO" "No secrets with expiry dates found" "$SILENT"
    continue
  else
    for SECRET in $(echo "$SECRETS" | jq -c); do
      SECRET_NAME=$(echo "$SECRET" | jq -rc '.secret_name')
      SECRET_EXPIRY=$(echo "$SECRET" | jq -rc '.expiry_date')

      # Check expiry of existing token
      SECRET_EXPIRY_TIMESTAMP=$(get_timestamp "$SECRET_EXPIRY")
      DATE_90_TIMESTAMP=$(get_timestamp "$DATE_90 23:59:59") # End of the day for 90 days ago
      TODAY_TIMESTAMP=$(get_timestamp "$TODAY 00:00:00")    # Start of today

      if [[ "$SECRET_EXPIRY_TIMESTAMP" -lt "$TODAY_TIMESTAMP" ]]; then
        SECRET_STATUS="Expired"
        BIN_EXPIRED="$SECRET, $BIN_EXPIRED"
      elif [[ "$SECRET_EXPIRY_TIMESTAMP" -lt "$DATE_90_TIMESTAMP" ]]; then
        SECRET_STATUS="Expiring soon"
        BIN_EXPIRING="$SECRET, $BIN_EXPIRING"
      else
        SECRET_STATUS="Valid"
        BIN_VALID="$SECRET, $BIN_VALID"
      fi

      print "INFO" "Secret: $SECRET_NAME | Expiry Date: $SECRET_EXPIRY) | State: $SECRET_STATUS" "$SILENT"

      if [ "$SECRET_STATUS" != "Valid" ] && [ "$NOTIFY" == 1 ]; then
        bash "$APP_ROOT/bin/notify" \
          -t ":warning: *Key Vault:* $KV_NAME | *Secret:* <https://portal.azure.com/?feature.msaljs=true#@platform.education.gov.uk/asset/Microsoft_Azure_KeyVault/Secret/https://$KV_NAME.vault.azure.net/secrets/$SECRET_NAME|$SECRET_NAME> | *Expiry Date:* $SECRET_EXPIRY_EXPIRY_DATE"
      fi

      TOTAL_SECRET_COUNT=$((TOTAL_SECRET_COUNT+1))
    done
  fi

  if [ "$BIN_EXPIRING" == "" ] && [ "$BIN_EXPIRED" == "" ]; then
    print "INFO" "Secrets are still valid in Key Vault '$KV_NAME'" "$SILENT"
  else
    if [ "$BIN_EXPIRING" != "" ]; then
      BIN_EXPIRING="[${BIN_EXPIRING/%, /}]"
      BIN_EXPIRING_COUNT=$(echo "$BIN_EXPIRING" | jq -r 'length')
      BIN_EXPIRING_SECRET_NAMES=$(echo "$BIN_EXPIRING" | jq -rc '.[].secret_name')
      TOTAL_EXPIRING_COUNT=$((TOTAL_EXPIRING_COUNT + BIN_EXPIRING_COUNT))

      print "WARNING" "$BIN_EXPIRING_COUNT Secrets were found that are close to expiry in Key Vault '$KV_NAME'. You should renew these:"
      print "WARNING" "$BIN_EXPIRING_SECRET_NAMES"
    fi
    if [ "$BIN_EXPIRED" != "" ]; then
      BIN_EXPIRED="[${BIN_EXPIRED/%, /}]"
      BIN_EXPIRED_COUNT=$(echo "$BIN_EXPIRED" | jq -r 'length')
      BIN_EXPIRED_SECRET_NAMES=$(echo "$BIN_EXPIRED" | jq -rc '.[].secret_name')
      TOTAL_EXPIRED_COUNT=$((TOTAL_EXPIRED_COUNT + BIN_EXPIRED_COUNT))

      print "ERROR" "$BIN_EXPIRED_COUNT Secrets were found that have expired in Key Vault '$KV_NAME'. You should remove them if they are not in use:"
      print "ERROR" "$BIN_EXPIRED_SECRET_NAMES"
    fi
  fi
done

LOG_FINAL="Finished scanning $COUNT_KEY_VAULT Key Vaults and $TOTAL_SECRET_COUNT secrets. $TOTAL_EXPIRED_COUNT were expired. $TOTAL_EXPIRING_COUNT were close to expiry."

print "INFO" "$LOG_FINAL"

if [ "$NOTIFY" == 1 ]; then
  bash "$APP_ROOT/bin/notify" -t "$LOG_FINAL"
fi
